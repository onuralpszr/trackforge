{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Index","text":"<p>Trackforge is a unified, high-performance computer vision tracking library built with Rust and exposed to Python. It implements state-of-the-art algorithms like ByteTrack with generic Kalman Filters.</p>","path":["Index"],"tags":[]},{"location":"#features","level":2,"title":"Features","text":"<ul> <li>üöÄ High Performance: Written in Rust for maximum speed and memory safety.</li> <li>üêç Python Bindings: Seamless integration with the Python ecosystem via PyO3.</li> <li>üëÅÔ∏è Computer Vision Ready: Designed for real-time tracking tasks.</li> <li>üõ†Ô∏è Unified API: Consistent interface for various tracking algorithms.</li> </ul>","path":["Index"],"tags":[]},{"location":"#quick-start","level":2,"title":"Quick Start","text":"","path":["Index"],"tags":[]},{"location":"#installation","level":3,"title":"Installation","text":"<pre><code>pip install trackforge\n</code></pre>","path":["Index"],"tags":[]},{"location":"#usage","level":3,"title":"Usage","text":"<pre><code>import trackforge\n\n# Example usage (update with actual API)\ntracker = trackforge.ByteTrack()\n</code></pre>","path":["Index"],"tags":[]},{"location":"#documentation","level":2,"title":"Documentation","text":"<ul> <li>Python API Reference</li> <li>Rust API Reference</li> </ul>","path":["Index"],"tags":[]},{"location":"examples/","level":1,"title":"Examples","text":"","path":["Examples"],"tags":[]},{"location":"examples/#rust-examples","level":2,"title":"Rust Examples","text":"","path":["Examples"],"tags":[]},{"location":"examples/#bytetrack-demo","level":3,"title":"ByteTrack Demo","text":"<pre><code>use trackforge::trackers::byte_track::ByteTrack;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize ByteTrack\n    // track_thresh = 0.5: Threshold for high confidence detections\n    // track_buffer = 30: Frames to keep lost tracks alive\n    // match_thresh = 0.8: IoU threshold for matching\n    // det_thresh = 0.6: Threshold for detection initialization\n    let mut tracker = ByteTrack::new(0.5, 30, 0.8, 0.6);\n\n    // Simulated detection input: [x, y, w, h], score, class_id\n    let frame_1_detections = vec![\n        ([100.0, 100.0, 50.0, 100.0], 0.9, 0),\n        ([200.0, 200.0, 60.0, 120.0], 0.85, 0),\n    ];\n\n    println!(\"Processing Frame 1...\");\n    let tracks_1 = tracker.update(frame_1_detections);\n\n    for t in tracks_1 {\n        println!(\n            \"Track ID: {}, Box: {:?}, Score: {:.2}\",\n            t.track_id, t.tlwh, t.score\n        );\n    }\n\n    // Simulated movement for Frame 2\n    let frame_2_detections = vec![\n        ([105.0, 102.0, 50.0, 100.0], 0.92, 0), // Moved slightly\n        ([202.0, 201.0, 60.0, 120.0], 0.88, 0),\n    ];\n\n    println!(\"\\nProcessing Frame 2...\");\n    let tracks_2 = tracker.update(frame_2_detections);\n\n    for t in tracks_2 {\n        println!(\n            \"Track ID: {}, Box: {:?}, Score: {:.2}\",\n            t.track_id, t.tlwh, t.score\n        );\n    }\n\n    Ok(())\n}\n</code></pre>","path":["Examples"],"tags":[]},{"location":"examples/#python-examples","level":2,"title":"Python Examples","text":"","path":["Examples"],"tags":[]},{"location":"examples/#bytetrack-demo_1","level":3,"title":"ByteTrack Demo","text":"<pre><code>import cv2\nfrom ultralytics import YOLO\nimport trackforge\nimport time\n\ndef run_tracking(video_path=\"test_video.mp4\", output_path=\"output_tracking.mp4\"):\n    # Load model\n    model = YOLO(\"yolo11n.pt\")\n\n    # Initialize Tracker\n    # track_thresh=0.1, track_buffer=30, match_thresh=0.8, det_thresh=0.1\n    tracker = trackforge.ByteTrack(0.1, 30, 0.8, 0.1)\n\n    # Open Video\n    cap = cv2.VideoCapture(video_path)\n    if not cap.isOpened():\n        print(f\"Error opening video file {video_path}\")\n        return\n\n    # Video Writer\n    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    fps = int(cap.get(cv2.CAP_PROP_FPS))\n\n    # Use MP4V codec\n    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))\n\n    frame_count = 0\n    t0 = time.time()\n\n    while cap.isOpened():\n        ret, frame = cap.read()\n        if not ret:\n            break\n\n        frame_count += 1\n\n        # Run Detection\n        results = model.predict(frame, verbose=False)\n\n        # Prepare detections for Rust tracker\n        detections_for_tracker = []\n\n        for result in results:\n            boxes = result.boxes\n            for box in boxes:\n                # get tlwh\n                xyxy = box.xyxy[0].cpu().numpy()\n                x1, y1, x2, y2 = xyxy\n                w = x2 - x1\n                h = y2 - y1\n                tlwh = [float(x1), float(y1), float(w), float(h)]\n                conf = float(box.conf[0].cpu().numpy())\n                cls = int(box.cls[0].cpu().numpy())\n\n                detections_for_tracker.append((tlwh, conf, cls))\n\n        # Update Tracker\n        # Returns list of (track_id, tlwh, score, class_id)\n        online_tracks = tracker.update(detections_for_tracker)\n\n        # Draw Tracks\n        for t in online_tracks:\n            track_id = t[0]\n            tlwh = t[1]\n            score = t[2]\n            class_id = t[3]\n\n            x1, y1, w, h = tlwh\n            x2 = x1 + w\n            y2 = y1 + h\n\n            # Draw box\n            color = (0, 255, 0) # Green\n            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), color, 2)\n\n            # Draw Label\n            label = f\"ID: {track_id} {model.names[class_id]} {score:.2f}\"\n            cv2.putText(frame, label, (int(x1), int(y1) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)\n\n        # Draw frame count\n        cv2.putText(frame, f\"Frame: {frame_count}\", (20, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)\n\n        out.write(frame)\n        if frame_count % 50 == 0:\n            print(f\"Processed {frame_count} frames...\")\n\n    t1 = time.time()\n    print(f\"Done. Processed {frame_count} frames in {t1-t0:.2f}s ({(frame_count / (t1-t0)):.1f} fps)\")\n\n    cap.release()\n    out.release()\n    print(f\"Saved output video to {output_path}\")\n\nif __name__ == \"__main__\":\n    run_tracking()\n</code></pre>","path":["Examples"],"tags":[]},{"location":"api/","level":1,"title":"Crate <code>trackforge</code>","text":"<p>Version: 0.1.7</p> <p>Trackforge is a unified, high-performance computer vision tracking library, implemented in Rust and exposed as a Python package.</p> <p>It provides state-of-the-art tracking algorithms like ByteTrack, optimized for speed and ease of use in both Rust and Python environments.</p>","path":["Crate trackforge"],"tags":[]},{"location":"api/#features","level":2,"title":"Features","text":"<ul> <li>High Performance: Native Rust implementation for maximum speed and memory safety.</li> <li>Python Bindings: Seamless integration with the Python ecosystem using <code>pyo3</code>.</li> <li>Unified API: Consistent interface for tracking tasks across both languages.</li> <li>ByteTrack: Robust multi-object tracking using Kalman filters and IoU matching.</li> </ul>","path":["Crate trackforge"],"tags":[]},{"location":"api/#usage-rust","level":2,"title":"Usage (Rust)","text":"<pre><code>use trackforge::trackers::byte_track::ByteTrack;\n\n// Initialize ByteTrack\nlet mut tracker = ByteTrack::new(0.5, 30, 0.8, 0.6);\n\n// Detections: Vec&lt;([f32; 4], f32, i64)&gt;\nlet detections = vec![\n    ([100.0, 100.0, 50.0, 100.0], 0.9, 0),\n];\n\n// Update\nlet tracks = tracker.update(detections);\n\nfor t in tracks {\n    println!(\"ID: {}, Box: {:?}\", t.track_id, t.tlwh);\n}\n</code></pre>","path":["Crate trackforge"],"tags":[]},{"location":"api/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>trackers</code> mod Implementation of various multi-object tracking (MOT) algorithms. <code>traits</code> mod <code>types</code> mod Common types used across the Trackforge library. <code>utils</code> mod Utility functions for geometry and Kalman filtering.","path":["Crate trackforge"],"tags":[]},{"location":"api/#modules","level":2,"title":"Modules","text":"<ul> <li><code>trackers</code> ‚Äî Implementation of various multi-object tracking (MOT) algorithms.</li> <li><code>traits</code></li> <li><code>types</code> ‚Äî Common types used across the Trackforge library.</li> <li><code>utils</code> ‚Äî Utility functions for geometry and Kalman filtering.</li> </ul>","path":["Crate trackforge"],"tags":[]},{"location":"api/trackers/","level":1,"title":"Module trackers","text":"<p>trackforge / trackers</p>","path":["Module trackers"],"tags":[]},{"location":"api/trackers/#module-trackers","level":1,"title":"Module <code>trackers</code>","text":"<p>Implementation of various multi-object tracking (MOT) algorithms.</p> <p>This module contains the core tracking logic for algorithms like ByteTrack, SORT, and DeepSORT.</p>","path":["Module trackers"],"tags":[]},{"location":"api/trackers/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>byte_track</code> mod # ByteTrack <code>deepsort</code> mod DeepSORT (Simple Online and Realtime Tracking with a Deep Association Metric) implementation. <code>sort</code> mod # SORT: Simple Online and Realtime Tracking","path":["Module trackers"],"tags":[]},{"location":"api/trackers/#modules","level":2,"title":"Modules","text":"<ul> <li><code>byte_track</code> ‚Äî # ByteTrack</li> <li><code>deepsort</code> ‚Äî DeepSORT (Simple Online and Realtime Tracking with a Deep Association Metric) implementation.</li> <li><code>sort</code> ‚Äî # SORT: Simple Online and Realtime Tracking</li> </ul>","path":["Module trackers"],"tags":[]},{"location":"api/trackers/byte_track/","level":1,"title":"Module byte_track","text":"<p>trackforge / trackers / byte_track</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#module-byte_track","level":1,"title":"Module <code>byte_track</code>","text":"","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#bytetrack","level":1,"title":"ByteTrack","text":"<p>ByteTrack: Multi-Object Tracking by Associating Every Detection Box</p> <p>Yifu Zhang, Peize Sun, Yi Jiang, Dongdong Yu, Fucheng Weng, Zehuan Yuan, Ping Luo, Wenyu Liu, Xinggang Wang</p> <p>arXiv 2110.06864</p> <p>ByteTrack is a simple, fast and strong multi-object tracker.</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#abstract","level":2,"title":"Abstract","text":"<p>Multi-object tracking (MOT) aims at estimating bounding boxes and identities of objects in videos. Most methods obtain identities by associating detection boxes whose scores are higher than a threshold. The objects with low detection scores, e.g. occluded objects, are simply thrown away, which brings non-negligible true object missing and fragmented trajectories. To solve this problem, ByteTrack presents a simple, effective and generic association method, tracking by associating every detection box instead of only the high score ones. For the low score detection boxes, it utilizes their similarities with tracklets to recover true objects and filter out the background detections.</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#original-repository","level":2,"title":"Original Repository","text":"<p>This is a clean-room Rust implementation of the ByteTrack algorithm as described in the original paper. The official reference implementation can be found at ifzhang/ByteTrack.</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#citation","level":2,"title":"Citation","text":"<pre><code>@article{zhang2022bytetrack,\n  title={ByteTrack: Multi-Object Tracking by Associating Every Detection Box},\n  author={Zhang, Yifu and Sun, Peize and Jiang, Yi and Yu, Dongdong and Weng, Fucheng and Yuan, Zehuan and Luo, Ping and Liu, Wenyu and Wang, Xinggang},\n  booktitle={Proceedings of the European Conference on Computer Vision (ECCV)},\n  year={2022}\n}\n</code></pre>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>ByteTrack</code> struct ByteTrack tracker implementation. <code>STrack</code> struct A Single Track (STrack) representing a tracked object. <code>TrackState</code> enum","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#types","level":2,"title":"Types","text":"","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#bytetrack_1","level":3,"title":"<code>ByteTrack</code>","text":"<pre><code>struct ByteTrack {\n    // [REDACTED: Private Fields]\n}\n</code></pre> <p>ByteTrack tracker implementation.</p> <p>ByteTrack is a simple, fast and strong multi-object tracker.</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#example","level":2,"title":"Example","text":"<pre><code>use trackforge::trackers::byte_track::ByteTrack;\n\n// Initialize tracker\nlet mut tracker = ByteTrack::new(0.5, 30, 0.8, 0.6);\n\n// Simulated detections: (tlwh_box, score, class_id)\nlet detections = vec![\n    ([100.0, 100.0, 50.0, 100.0], 0.9, 0),\n    ([200.0, 200.0, 60.0, 120.0], 0.85, 0),\n];\n\n// Update tracker\nlet tracks = tracker.update(detections);\n\nfor track in tracks {\n    println!(\"Track ID: {}, Box: {:?}\", track.track_id, track.tlwh);\n}\n</code></pre>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#abstract_1","level":2,"title":"Abstract","text":"","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#implementations","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(track_thresh: f32, track_buffer: usize, match_thresh: f32, det_thresh: f32) -&gt; Self\n</code></pre></p> <p>Create a new ByteTrack instance.</p> <p># Arguments</p> Argument Description <code>track_thresh</code> Threshold for high confidence detections (e.g., 0.5 or 0.6). <code>track_buffer</code> Number of frames to keep a lost track alive (e.g., 30). <code>match_thresh</code> IoU threshold for matching (e.g., 0.8). <code>det_thresh</code> Threshold for initializing a new track (usually same as or slightly lower than track_thresh). <p> <pre><code>fn update(&amp;mut self, output_results: Vec&lt;([f32; 4], f32, i64)&gt;) -&gt; Vec&lt;STrack&gt;\n</code></pre></p> <p>Update the tracker with detections from the current frame.</p> <p># Arguments</p> Argument Description <code>output_results</code> A vector of detections, where each detection is <code>(TLWH_Box, Score, ClassID)</code>. <p>Returns</p> <ul> <li><code>Vec&lt;STrack&gt;</code> - A list of active tracks in the current frame.</li> </ul>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#trait-implementations","level":4,"title":"Trait Implementations","text":"<p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#strack","level":3,"title":"<code>STrack</code>","text":"<pre><code>struct STrack {\n    pub tlwh: [f32; 4],\n    pub score: f32,\n    pub class_id: i64,\n    pub track_id: u64,\n    pub state: TrackState,\n    pub is_activated: bool,\n    pub frame_id: usize,\n    pub start_frame: usize,\n    pub tracklet_len: usize,\n    pub mean: crate::utils::kalman::StateVector,\n    pub covariance: crate::utils::kalman::CovarianceMatrix,\n}\n</code></pre> <p>A Single Track (STrack) representing a tracked object.</p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#fields","level":4,"title":"Fields","text":"Name Type Description <code>tlwh</code> <code>[f32; 4]</code> Bounding box in TLWH (Top-Left-Width-Height) format. <code>score</code> <code>f32</code> Detection confidence score. <code>class_id</code> <code>i64</code> Class ID of the object. <code>track_id</code> <code>u64</code> Unique track ID. <code>state</code> <code>TrackState</code> Current tracking state (New, Tracked, Lost, Removed). <code>is_activated</code> <code>bool</code> Whether the track is currently activated (confirmed). <code>frame_id</code> <code>usize</code> Current frame ID. <code>start_frame</code> <code>usize</code> Frame ID where the track started. <code>tracklet_len</code> <code>usize</code> Length of the tracklet (number of frames tracked). <code>mean</code> <code>crate::utils::kalman::StateVector</code> Kalman Filter state mean. <code>covariance</code> <code>crate::utils::kalman::CovarianceMatrix</code> Kalman Filter state covariance.","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#implementations_1","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(tlwh: [f32; 4], score: f32, class_id: i64) -&gt; Self\n</code></pre></p> <p> <pre><code>fn activate(&amp;mut self, kf: &amp;KalmanFilter, frame_id: usize)\n</code></pre></p> <p> <pre><code>fn re_activate(&amp;mut self, new_track: STrack, frame_id: usize, new_id: bool)\n</code></pre></p> <p> <pre><code>fn update(&amp;mut self, new_track: STrack, frame_id: usize)\n</code></pre></p> <p> <pre><code>fn predict(&amp;mut self, kf: &amp;KalmanFilter)\n</code></pre></p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#trait-implementations_1","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for STrack\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; STrack\n</code></pre></p> <pre><code>impl Debug for STrack\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#trackstate","level":3,"title":"<code>TrackState</code>","text":"<pre><code>enum TrackState {\n    New,\n    Tracked,\n    Lost,\n    Removed,\n}\n</code></pre>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/byte_track/#trait-implementations_2","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for TrackState\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; TrackState\n</code></pre></p> <pre><code>impl Copy for TrackState\n</code></pre> <pre><code>impl Debug for TrackState\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl Eq for TrackState\n</code></pre> <pre><code>impl PartialEq for TrackState\n</code></pre> <p> <pre><code>fn eq(&amp;self, other: &amp;TrackState) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module byte_track"],"tags":[]},{"location":"api/trackers/deepsort/","level":1,"title":"Module deepsort","text":"<p>trackforge / trackers / deepsort</p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#module-deepsort","level":1,"title":"Module <code>deepsort</code>","text":"<p>DeepSORT (Simple Online and Realtime Tracking with a Deep Association Metric) implementation.</p> <p>This module provides a DeepSORT tracker that uses appearance features for more robust tracking.</p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>DeepSort</code> struct Deep SORT tracker implementation.","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#types","level":2,"title":"Types","text":"","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#track","level":3,"title":"<code>Track</code>","text":"<pre><code>struct Track {\n    pub track_id: u64,\n    pub class_id: i64,\n    pub hits: usize,\n    pub age: usize,\n    pub time_since_update: usize,\n    pub state: TrackState,\n    pub mean: crate::utils::kalman::StateVector,\n    pub covariance: crate::utils::kalman::CovarianceMatrix,\n    pub score: f32,\n    pub features: Vec&lt;Vec&lt;f32&gt;&gt;,\n    // [REDACTED: Private Fields]\n}\n</code></pre>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#fields","level":4,"title":"Fields","text":"Name Type Description <code>features</code> <code>Vec&lt;Vec&lt;f32&gt;&gt;</code> Features (embeddings) collected during the current update cycle or while tentative. These are flushed to the metric gallery when appropriate.","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#implementations","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(mean: StateVector, covariance: CovarianceMatrix, track_id: u64, class_id: i64, n_init: usize, max_age: usize, score: f32, feature: Vec&lt;f32&gt;) -&gt; Self\n</code></pre></p> <p> <pre><code>fn tlwh_to_xyah(tlwh: &amp;[f32; 4]) -&gt; MeasurementVector\n</code></pre></p> <p>Convert TLWH to (x, y, a, h)</p> <p> <pre><code>fn xyah_to_tlwh(state: &amp;StateVector) -&gt; [f32; 4]\n</code></pre></p> <p>Convert (x, y, a, h) to TLWH</p> <p> <pre><code>fn to_tlwh(&amp;self) -&gt; [f32; 4]\n</code></pre></p> <p> <pre><code>fn predict(&amp;mut self, kf: &amp;KalmanFilter)\n</code></pre></p> <p> <pre><code>fn update(&amp;mut self, kf: &amp;KalmanFilter, detection: &amp;MeasurementVector, score: f32, class_id: i64, feature: Vec&lt;f32&gt;)\n</code></pre></p> <p> <pre><code>fn mark_missed(&amp;mut self)\n</code></pre></p> <p> <pre><code>fn is_confirmed(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn is_tentative(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn is_deleted(&amp;self) -&gt; bool\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trait-implementations","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for Track\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; Track\n</code></pre></p> <pre><code>impl Debug for Track\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#deepsorttracker","level":3,"title":"<code>DeepSortTracker</code>","text":"<pre><code>struct DeepSortTracker {\n    pub metric: crate::trackers::deepsort::nn_matching::NearestNeighborDistanceMetric,\n    pub max_age: usize,\n    pub n_init: usize,\n    pub tracks: Vec&lt;crate::trackers::deepsort::track::Track&gt;,\n    pub kf: crate::utils::kalman::KalmanFilter,\n    pub max_iou_distance: f32,\n}\n</code></pre>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#implementations_1","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(metric: NearestNeighborDistanceMetric, max_age: usize, n_init: usize, max_iou_distance: f32) -&gt; Self\n</code></pre></p> <p> <pre><code>fn predict(&amp;mut self)\n</code></pre></p> <p> <pre><code>fn update(&amp;mut self, detections: &amp;[(crate::types::BoundingBox, f32, i64)], embeddings: &amp;[Vec&lt;f32&gt;])\n</code></pre></p> <p> <pre><code>fn initiate_track(&amp;mut self, tlwh: &amp;[f32; 4], score: f32, class_id: i64, embedding: Vec&lt;f32&gt;)\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trait-implementations_1","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for DeepSortTracker\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; DeepSortTracker\n</code></pre></p> <pre><code>impl Debug for DeepSortTracker\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#deepsorte-appearanceextractor","level":3,"title":"<code>DeepSort&lt;E: AppearanceExtractor&gt;</code>","text":"<pre><code>struct DeepSort&lt;E: AppearanceExtractor&gt; {\n    // [REDACTED: Private Fields]\n}\n</code></pre> <p>Deep SORT tracker implementation.</p> <p>Wraps the tracker logic and appearance feature extraction.</p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#implementations_2","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(extractor: E, max_age: usize, n_init: usize, max_iou_distance: f32, max_cosine_distance: f32, nn_budget: usize) -&gt; Self\n</code></pre></p> <p>Create a new Deep SORT tracker.</p> <p># Arguments</p> Argument Description <code>extractor</code> The appearance feature extractor. <code>max_age</code> Maximum frames to keep a track without detection. Default: 70. <code>n_init</code> Minimum hits to confirm a track. Default: 3. <code>max_iou_distance</code> Threshold for IoU matching. Default: 0.7. <code>max_cosine_distance</code> Threshold for cosine distance matching. Default: 0.2. <code>nn_budget</code> Maximum library size for appearance features. Default: 100. <p> <pre><code>fn update(&amp;mut self, image: &amp;DynamicImage, detections: Vec&lt;(BoundingBox, f32, i64)&gt;) -&gt; Result&lt;Vec&lt;Track&gt;, Box&lt;dyn Error&gt;&gt;\n</code></pre></p> <p>Update the tracker with new frame and detections.</p> <p># Arguments</p> Argument Description <code>image</code> The current video frame. <code>detections</code> List of (BoundingBox, Score, ClassID). <p># Returns</p> <p>List of confirmed tracks.</p> <p> <pre><code>fn new_default(extractor: E) -&gt; Self\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trait-implementations_2","level":4,"title":"Trait Implementations","text":"<p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#metric","level":3,"title":"<code>Metric</code>","text":"<pre><code>enum Metric {\n    Euclidean,\n    Cosine,\n}\n</code></pre>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trait-implementations_3","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for Metric\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; Metric\n</code></pre></p> <pre><code>impl Copy for Metric\n</code></pre> <pre><code>impl Debug for Metric\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl Eq for Metric\n</code></pre> <pre><code>impl PartialEq for Metric\n</code></pre> <p> <pre><code>fn eq(&amp;self, other: &amp;Metric) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trackstate","level":3,"title":"<code>TrackState</code>","text":"<pre><code>enum TrackState {\n    Tentative,\n    Confirmed,\n    Deleted,\n}\n</code></pre>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/deepsort/#trait-implementations_4","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for TrackState\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; TrackState\n</code></pre></p> <pre><code>impl Copy for TrackState\n</code></pre> <pre><code>impl Debug for TrackState\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl Eq for TrackState\n</code></pre> <pre><code>impl PartialEq for TrackState\n</code></pre> <p> <pre><code>fn eq(&amp;self, other: &amp;TrackState) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module deepsort"],"tags":[]},{"location":"api/trackers/sort/","level":1,"title":"Module sort","text":"<p>trackforge / trackers / sort</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#module-sort","level":1,"title":"Module <code>sort</code>","text":"","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#sort-simple-online-and-realtime-tracking","level":1,"title":"SORT: Simple Online and Realtime Tracking","text":"<p>This module implements the SORT (Simple Online and Realtime Tracking) algorithm.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#algorithm-overview","level":2,"title":"Algorithm Overview","text":"<p>SORT is a simple yet effective multi-object tracking algorithm that combines: - Kalman Filtering for motion prediction - Hungarian Algorithm for data association using IoU (Intersection over Union)</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#key-features","level":2,"title":"Key Features","text":"<ul> <li>Real-time performance: Designed for speed with minimal computational overhead</li> <li>No appearance features: Uses only bounding box information</li> <li>Simple track management: Tracks are created, confirmed, and deleted based on hit/miss counts</li> </ul>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#parameters","level":2,"title":"Parameters","text":"Parameter Default Description <code>max_age</code> 1 Maximum frames to keep a track without detection <code>min_hits</code> 3 Minimum consecutive hits before track is confirmed <code>iou_threshold</code> 0.3 Minimum IoU for matching detection to track","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#references","level":2,"title":"References","text":"<p>Simple Online and Realtime Tracking Alex Bewley, Zongyuan Ge, Lionel Ott, Fabio Ramos, Ben Upcroft IEEE International Conference on Image Processing (ICIP), 2016 arXiv:1602.00763</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>Sort</code> struct SORT (Simple Online and Realtime Tracking) tracker. <code>SortTrack</code> struct A single track in SORT. <code>SortTrackState</code> enum Track state enumeration for SORT.","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#types","level":2,"title":"Types","text":"","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#sort","level":3,"title":"<code>Sort</code>","text":"<pre><code>struct Sort {\n    // [REDACTED: Private Fields]\n}\n</code></pre> <p>SORT (Simple Online and Realtime Tracking) tracker.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#example","level":2,"title":"Example","text":"<pre><code>use trackforge::trackers::sort::Sort;\n\n// Initialize tracker\nlet mut tracker = Sort::new(1, 3, 0.3);\n\n// Simulated detections: (tlwh_box, score, class_id)\nlet detections = vec![\n    ([100.0, 100.0, 50.0, 100.0], 0.9, 0),\n    ([200.0, 200.0, 60.0, 120.0], 0.85, 0),\n];\n\n// Update tracker\nlet tracks = tracker.update(detections);\n\nfor track in tracks {\n    println!(\"Track ID: {}, Box: {:?}\", track.track_id, track.tlwh);\n}\n</code></pre>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#implementations","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(max_age: usize, min_hits: usize, iou_threshold: f32) -&gt; Self\n</code></pre></p> <p>Create a new SORT tracker instance.</p> <p># Arguments</p> Argument Description <code>max_age</code> Maximum frames to keep a track without detection (default: 1). <code>min_hits</code> Minimum consecutive hits before track is confirmed (default: 3). <code>iou_threshold</code> Minimum IoU for matching detection to track (default: 0.3). <p> <pre><code>fn update(&amp;mut self, detections: Vec&lt;([f32; 4], f32, i64)&gt;) -&gt; Vec&lt;SortTrack&gt;\n</code></pre></p> <p>Update the tracker with detections from the current frame.</p> <p># Arguments</p> Argument Description <code>detections</code> A vector of detections, where each detection is <code>(TLWH_Box, Score, ClassID)</code>. <p># Returns</p> <p>A vector of confirmed tracks.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#trait-implementations","level":4,"title":"Trait Implementations","text":"<pre><code>impl Default for Sort\n</code></pre> <p> <pre><code>fn default() -&gt; Self\n</code></pre></p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#implr-readprimitiver-for-sort","level":5,"title":"<code>impl&lt;R&gt; ReadPrimitive&lt;R&gt; for Sort</code>","text":"<p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#sorttrack","level":3,"title":"<code>SortTrack</code>","text":"<pre><code>struct SortTrack {\n    pub tlwh: [f32; 4],\n    pub score: f32,\n    pub class_id: i64,\n    pub track_id: u64,\n    pub state: SortTrackState,\n    pub hits: usize,\n    pub time_since_update: usize,\n    pub age: usize,\n    // [REDACTED: Private Fields]\n}\n</code></pre> <p>A single track in SORT.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#fields","level":4,"title":"Fields","text":"Name Type Description <code>tlwh</code> <code>[f32; 4]</code> Bounding box in TLWH (Top-Left-Width-Height) format. <code>score</code> <code>f32</code> Detection confidence score. <code>class_id</code> <code>i64</code> Class ID of the object. <code>track_id</code> <code>u64</code> Unique track ID. <code>state</code> <code>SortTrackState</code> Current tracking state. <code>hits</code> <code>usize</code> Number of consecutive hits (matched detections). <code>time_since_update</code> <code>usize</code> Number of consecutive misses (no matched detection). <code>age</code> <code>usize</code> Total age of the track in frames.","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#implementations_1","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(tlwh: [f32; 4], score: f32, class_id: i64, kf: &amp;KalmanFilter) -&gt; Self\n</code></pre></p> <p>Create a new track from a detection.</p> <p> <pre><code>fn predict(&amp;mut self, kf: &amp;KalmanFilter)\n</code></pre></p> <p>Predict the next state using Kalman filter.</p> <p> <pre><code>fn mark_deleted(&amp;mut self)\n</code></pre></p> <p>Mark track as deleted.</p> <p> <pre><code>fn is_confirmed(&amp;self) -&gt; bool\n</code></pre></p> <p>Check if track should be confirmed based on min_hits.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#trait-implementations_1","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for SortTrack\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; SortTrack\n</code></pre></p> <pre><code>impl Debug for SortTrack\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#sorttrackstate","level":3,"title":"<code>SortTrackState</code>","text":"<pre><code>enum SortTrackState {\n    Tentative,\n    Confirmed,\n    Deleted,\n}\n</code></pre> <p>Track state enumeration for SORT.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#variants","level":4,"title":"Variants","text":"<ul> <li><code>Tentative</code></li> </ul> <p>Track is tentative (not yet confirmed).</p> <ul> <li><code>Confirmed</code></li> </ul> <p>Track is confirmed and active.</p> <ul> <li><code>Deleted</code></li> </ul> <p>Track is deleted.</p>","path":["Module sort"],"tags":[]},{"location":"api/trackers/sort/#trait-implementations_2","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for SortTrackState\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; SortTrackState\n</code></pre></p> <pre><code>impl Copy for SortTrackState\n</code></pre> <pre><code>impl Debug for SortTrackState\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl Eq for SortTrackState\n</code></pre> <pre><code>impl PartialEq for SortTrackState\n</code></pre> <p> <pre><code>fn eq(&amp;self, other: &amp;SortTrackState) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module sort"],"tags":[]},{"location":"api/traits/","level":1,"title":"Module traits","text":"<p>trackforge / traits</p>","path":["Module traits"],"tags":[]},{"location":"api/traits/#module-traits","level":1,"title":"Module <code>traits</code>","text":"","path":["Module traits"],"tags":[]},{"location":"api/traits/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>AppearanceExtractor</code> trait Trait for extracting appearance features (embeddings) from images.","path":["Module traits"],"tags":[]},{"location":"api/traits/#traits","level":2,"title":"Traits","text":"","path":["Module traits"],"tags":[]},{"location":"api/traits/#appearanceextractor","level":3,"title":"<code>AppearanceExtractor</code>","text":"<pre><code>trait AppearanceExtractor { ... }\n</code></pre> <p>Trait for extracting appearance features (embeddings) from images.</p> <p>This allows decoupling the tracker logic (DeepSORT) from the model execution (ONNX, PyTorch via Python, etc.).</p>","path":["Module traits"],"tags":[]},{"location":"api/traits/#required-methods","level":4,"title":"Required Methods","text":"<ul> <li><code>fn extract(&amp;mut self, image: &amp;DynamicImage, bboxes: &amp;[BoundingBox]) -&gt; Result&lt;Vec&lt;Vec&lt;f32&gt;&gt;, Box&lt;dyn Error&gt;&gt;</code></li> </ul> <p>Extract features for a list of bounding boxes from a given image.</p>","path":["Module traits"],"tags":[]},{"location":"api/types/","level":1,"title":"Module types","text":"<p>trackforge / types</p>","path":["Module types"],"tags":[]},{"location":"api/types/#module-types","level":1,"title":"Module <code>types</code>","text":"<p>Common types used across the Trackforge library.</p> <p>This module defines fundamental structures like <code>BoundingBox</code>.</p>","path":["Module types"],"tags":[]},{"location":"api/types/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>BoundingBox</code> struct Represents a bounding box in 2D space.","path":["Module types"],"tags":[]},{"location":"api/types/#types","level":2,"title":"Types","text":"","path":["Module types"],"tags":[]},{"location":"api/types/#boundingbox","level":3,"title":"<code>BoundingBox</code>","text":"<pre><code>struct BoundingBox {\n    pub x: f32,\n    pub y: f32,\n    pub width: f32,\n    pub height: f32,\n}\n</code></pre> <p>Represents a bounding box in 2D space.</p>","path":["Module types"],"tags":[]},{"location":"api/types/#implementations","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(x: f32, y: f32, width: f32, height: f32) -&gt; Self\n</code></pre></p>","path":["Module types"],"tags":[]},{"location":"api/types/#trait-implementations","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for BoundingBox\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; BoundingBox\n</code></pre></p> <pre><code>impl Copy for BoundingBox\n</code></pre> <pre><code>impl Debug for BoundingBox\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl PartialEq for BoundingBox\n</code></pre> <p> <pre><code>fn eq(&amp;self, other: &amp;BoundingBox) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module types"],"tags":[]},{"location":"api/utils/","level":1,"title":"Module utils","text":"<p>trackforge / utils</p>","path":["Module utils"],"tags":[]},{"location":"api/utils/#module-utils","level":1,"title":"Module <code>utils</code>","text":"<p>Utility functions for geometry and Kalman filtering.</p> <p>This module provides common mathematical and geometric tools used by the trackers.</p>","path":["Module utils"],"tags":[]},{"location":"api/utils/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>geometry</code> mod <code>kalman</code> mod","path":["Module utils"],"tags":[]},{"location":"api/utils/#modules","level":2,"title":"Modules","text":"<ul> <li><code>geometry</code></li> <li><code>kalman</code></li> </ul>","path":["Module utils"],"tags":[]},{"location":"api/utils/geometry/","level":1,"title":"Module geometry","text":"<p>trackforge / utils / geometry</p>","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#module-geometry","level":1,"title":"Module <code>geometry</code>","text":"","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>iou</code> fn Calculate Intersection over Union (IoU) between two bounding boxes. <code>iou_batch</code> fn Calculate IoU matrix between two lists of bounding boxes. <code>tlwh_to_tlbr</code> fn Convert a bounding box from TLWH (Top-Left-Width-Height) to TLBR (Top-Left-Bottom-Right) format.","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#functions","level":2,"title":"Functions","text":"","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#iou","level":3,"title":"<code>iou</code>","text":"<pre><code>fn iou(box1: &amp;[f32; 4], box2: &amp;[f32; 4]) -&gt; f32\n</code></pre> <p>Calculate Intersection over Union (IoU) between two bounding boxes.</p>","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#arguments","level":1,"title":"Arguments","text":"Argument Description <code>box1</code> First bounding box in TLWH format. <code>box2</code> Second bounding box in TLWH format.","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#iou_batch","level":3,"title":"<code>iou_batch</code>","text":"<pre><code>fn iou_batch(bboxes1: &amp;[[f32; 4]], bboxes2: &amp;[[f32; 4]]) -&gt; Vec&lt;Vec&lt;f32&gt;&gt;\n</code></pre> <p>Calculate IoU matrix between two lists of bounding boxes.</p> <p>Returns a 2D vector where <code>result[i][j]</code> is the IoU between <code>bboxes1[i]</code> and <code>bboxes2[j]</code>.</p>","path":["Module geometry"],"tags":[]},{"location":"api/utils/geometry/#tlwh_to_tlbr","level":3,"title":"<code>tlwh_to_tlbr</code>","text":"<pre><code>fn tlwh_to_tlbr(tlwh: &amp;[f32; 4]) -&gt; [f32; 4]\n</code></pre> <p>Convert a bounding box from TLWH (Top-Left-Width-Height) to TLBR (Top-Left-Bottom-Right) format.</p>","path":["Module geometry"],"tags":[]},{"location":"api/utils/kalman/","level":1,"title":"Module kalman","text":"<p>trackforge / utils / kalman</p>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#module-kalman","level":1,"title":"Module <code>kalman</code>","text":"","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#quick-reference","level":2,"title":"Quick Reference","text":"Item Kind Description <code>KalmanFilter</code> struct A standard Kalman Filter implementation for bounding box tracking. <code>CovarianceMatrix</code> type <code>MeasurementMatrix</code> type <code>MeasurementVector</code> type <code>StateVector</code> type","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#types","level":2,"title":"Types","text":"","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#kalmanfilter","level":3,"title":"<code>KalmanFilter</code>","text":"<pre><code>struct KalmanFilter {\n    // [REDACTED: Private Fields]\n}\n</code></pre> <p>A standard Kalman Filter implementation for bounding box tracking.</p> <p>Ref: \"Simple Online and Realtime Tracking with a Deep Association Metric\" (DeepSORT)</p>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#implementations","level":4,"title":"Implementations","text":"<p> <pre><code>fn new(std_weight_position: f32, std_weight_velocity: f32) -&gt; Self\n</code></pre></p> <p>Create a new Kalman Filter instance.</p> <p> <pre><code>fn initiate(&amp;self, measurement: &amp;MeasurementVector) -&gt; (StateVector, CovarianceMatrix)\n</code></pre></p> <p>Initiate the Kalman Filter state from a measurement.</p> <p># Arguments</p> Argument Description <code>measurement</code> The initial measurement vector <code>[x, y, a, h]</code>. <p># Returns</p> <p>A tuple containing the initial Mean vector and Covariance matrix.</p> <p> <pre><code>fn predict(&amp;self, mean: &amp;StateVector, covariance: &amp;CovarianceMatrix) -&gt; (StateVector, CovarianceMatrix)\n</code></pre></p> <p>Predict the next state of the Kalman Filter.</p> <p># Arguments</p> Argument Description <code>mean</code> The current state mean vector. <code>covariance</code> The current state covariance matrix. <p># Returns</p> <p>A tuple containing the predicted Mean vector and Covariance matrix.</p> <p> <pre><code>fn update(&amp;self, mean: &amp;StateVector, covariance: &amp;CovarianceMatrix, measurement: &amp;MeasurementVector) -&gt; (StateVector, CovarianceMatrix)\n</code></pre></p> <p>Update the Kalman Filter state with a new measurement.</p> <p># Arguments</p> Argument Description <code>mean</code> The predicted state mean vector. <code>covariance</code> The predicted state covariance matrix. <code>measurement</code> The new measurement vector <code>[x, y, a, h]</code>. <p># Returns</p> <p>A tuple containing the updated Mean vector and Covariance matrix.</p> <p> <pre><code>fn gating_distance(&amp;self, mean: &amp;StateVector, covariance: &amp;CovarianceMatrix, measurements: &amp;[MeasurementVector]) -&gt; Vec&lt;f32&gt;\n</code></pre></p> <p>Calculate the Mahalanobis distance between the track state and measurements.</p> <p># Arguments</p> Argument Description <code>mean</code> The current state mean. <code>covariance</code> The current state covariance. <code>measurements</code> A list of measurements to compare against. <code>only_position</code> If true, only use the position (x, y) components (not implemented). For this implementation, we use the full measurement vector [x, y, a, h]. <p># Returns</p> <p>A vector of distances, one for each measurement.</p>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#trait-implementations","level":4,"title":"Trait Implementations","text":"<pre><code>impl Clone for KalmanFilter\n</code></pre> <p> <pre><code>fn clone(&amp;self) -&gt; KalmanFilter\n</code></pre></p> <pre><code>impl Debug for KalmanFilter\n</code></pre> <p> <pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result\n</code></pre></p> <pre><code>impl Default for KalmanFilter\n</code></pre> <p> <pre><code>fn default() -&gt; Self\n</code></pre></p>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#implr-readprimitiver-for-kalmanfilter","level":5,"title":"<code>impl&lt;R&gt; ReadPrimitive&lt;R&gt; for KalmanFilter</code>","text":"<p> <pre><code>fn to_subset(&amp;self) -&gt; Option&lt;SS&gt;\n</code></pre></p> <p> <pre><code>fn is_in_subset(&amp;self) -&gt; bool\n</code></pre></p> <p> <pre><code>fn to_subset_unchecked(&amp;self) -&gt; SS\n</code></pre></p> <p> <pre><code>fn from_subset(element: &amp;SS) -&gt; SP\n</code></pre></p>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#covariancematrix","level":3,"title":"<code>CovarianceMatrix</code>","text":"<pre><code>type CovarianceMatrix = nalgebra::SMatrix&lt;f32, 8, 8&gt;;\n</code></pre>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#measurementmatrix","level":3,"title":"<code>MeasurementMatrix</code>","text":"<pre><code>type MeasurementMatrix = nalgebra::SMatrix&lt;f32, 4, 8&gt;;\n</code></pre>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#measurementvector","level":3,"title":"<code>MeasurementVector</code>","text":"<pre><code>type MeasurementVector = nalgebra::SVector&lt;f32, 4&gt;;\n</code></pre>","path":["Module kalman"],"tags":[]},{"location":"api/utils/kalman/#statevector","level":3,"title":"<code>StateVector</code>","text":"<pre><code>type StateVector = nalgebra::SVector&lt;f32, 8&gt;;\n</code></pre>","path":["Module kalman"],"tags":[]},{"location":"reference/python/","level":1,"title":"Python API Reference","text":"","path":["Python API Reference"],"tags":[]},{"location":"reference/python/#trackforge","level":2,"title":"<code>trackforge</code>","text":"","path":["Python API Reference"],"tags":[]}]}